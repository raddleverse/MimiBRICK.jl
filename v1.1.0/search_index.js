var documenterSearchIndex = {"docs":
[{"location":"install_and_examples/#Installation-and-Examples","page":"Installation and Examples","title":"Installation and Examples","text":"","category":"section"},{"location":"install_and_examples/","page":"Installation and Examples","title":"Installation and Examples","text":"This repository will have the latest \"standard\" BRICK version and codes demonstrating its calibration in three configurations: (i) alone (forced by temperature and ocean heat), (ii) coupled to DOECLIM, and (iii) coupled to SNEASY. Standard calibration output will be provided as well as examples and scripts for downscaling the projections to a 1-degree grid for local sea-level rise.","category":"page"},{"location":"install_and_examples/#Recommended-Use","page":"Installation and Examples","title":"Recommended Use","text":"","category":"section"},{"location":"install_and_examples/","page":"Installation and Examples","title":"Installation and Examples","text":"If you would like to use previously published BRICK results as part of a new analysis, but do not necessarily want to re-run the model, then we recommend to go to the accompanying Zenodo repository. In the near future, we will compile a library of other previously published studies using BRICK, including any other relevant outputs.\nIf you would like to run the model yourself, then you are in the right place!\nIt is assumed that users will not clone/download this Git repository. Instead, you can add and use the package as described below. Those commands and the commands to set up and run the model can be executed from the directories that contain the rest of your project codes.\nLoad the MimiBRICK package (or if you wish to edit the package either fork the master branch from this repository or download the zipped file of codes)\nDo your analysis\nAlso please let us know of any model modifications and/or bug fixes that might usefully be incorporated into the main BRICK codes. Creating an \"Issue\" here is a great way to do that (top horizontal menu bar in the GitHub browser).","category":"page"},{"location":"install_and_examples/#How-To-Install-MimiBRICK","page":"Installation and Examples","title":"How To Install MimiBRICK","text":"","category":"section"},{"location":"install_and_examples/","page":"Installation and Examples","title":"Installation and Examples","text":"This code was created using Julia v1.6 and requires several Julia packages. It is recommended that you use Julia v1.6 (or later). Julia may be downloaded from http://julialang.org/downloads/.","category":"page"},{"location":"install_and_examples/","page":"Installation and Examples","title":"Installation and Examples","text":"(1) Run the following line to install the Mimi implementation of BRICK:","category":"page"},{"location":"install_and_examples/","page":"Installation and Examples","title":"Installation and Examples","text":"]\nadd MimiBRICK","category":"page"},{"location":"install_and_examples/","page":"Installation and Examples","title":"Installation and Examples","text":"(2) To exit back to Julia, hit the backspace key.","category":"page"},{"location":"install_and_examples/#Running-baseline-cases-with-default-parameters-and-unit-tests","page":"Installation and Examples","title":"Running baseline cases with default parameters and unit tests","text":"","category":"section"},{"location":"install_and_examples/","page":"Installation and Examples","title":"Installation and Examples","text":"If you would like to take a look at the unit tests run with Continuous Integration for this package, feel free to take a look at the runtests.jl file, and the separate testing scripts it calls here.","category":"page"},{"location":"install_and_examples/#More-detailed-examples","page":"Installation and Examples","title":"More detailed examples","text":"","category":"section"},{"location":"install_and_examples/","page":"Installation and Examples","title":"Installation and Examples","text":"Below, we review the three main configurations of the model that we anticipate being used. However, in the examples directory, you can find further examples conducting the statistical calibration, creating posterior model hindcasts and projections, and downscaling these hindcasts and projections to local sea-level changes. Those examples are in Jupyter notebooks. To open and run one, you will need to clone or fork the MimiBRICK.jl repository. Then, navigate to it in the Julia terminal and run:","category":"page"},{"location":"install_and_examples/","page":"Installation and Examples","title":"Installation and Examples","text":"using Pkg; Pkg.add(IJulia)\nusing IJulia; notebook(dir=\"examples\")","category":"page"},{"location":"install_and_examples/","page":"Installation and Examples","title":"Installation and Examples","text":"You can then select and run the Jupyter notebook of your chosing in the Jupyter browser window (which will open in a web browser).","category":"page"},{"location":"install_and_examples/#BRICK-standalone-(with-temperature-and-ocean-heat-uptake-exogenous-forcing)","page":"Installation and Examples","title":"BRICK standalone (with temperature and ocean heat uptake exogenous forcing)","text":"","category":"section"},{"location":"install_and_examples/","page":"Installation and Examples","title":"Installation and Examples","text":"This is the first test that is done in test/runtests/test_default.jl. Since it does not require DOECLIM or SNEASY, you can run BRICK using temperature and ocean heat uptake forcing data by running in the Julia console:","category":"page"},{"location":"install_and_examples/","page":"Installation and Examples","title":"Installation and Examples","text":"using MimiBRICK\nm = MimiBRICK.get_model()\nrun(m)","category":"page"},{"location":"install_and_examples/","page":"Installation and Examples","title":"Installation and Examples","text":"You can plot the output fields in the model object m using (for example) the Plots Julia plotting package. First, let's grab the years over which the model was run. This is a dimension in the model. We can retrieve it by using the dim_keys() function, from the Mimi package.","category":"page"},{"location":"install_and_examples/","page":"Installation and Examples","title":"Installation and Examples","text":"using Mimi\nyears = dim_keys(m, :time)","category":"page"},{"location":"install_and_examples/","page":"Installation and Examples","title":"Installation and Examples","text":"Then we can load the Plots package and make a figure of the global mean sea-level change. Note that the first argument into the m object specifies the component of our model, and the second argument specifies the field. Here, we are grabbing the sea_level_rise field from the global_sea_level component.","category":"page"},{"location":"install_and_examples/","page":"Installation and Examples","title":"Installation and Examples","text":"using Plots\nplot(years, m[:global_sea_level, :sea_level_rise])","category":"page"},{"location":"install_and_examples/","page":"Installation and Examples","title":"Installation and Examples","text":"Mimi also offers an explorer window to check these model output fields out. To use this, we need to load the Mimi package (if you haven't already).","category":"page"},{"location":"install_and_examples/","page":"Installation and Examples","title":"Installation and Examples","text":"using Mimi","category":"page"},{"location":"install_and_examples/","page":"Installation and Examples","title":"Installation and Examples","text":"Then, we can open the explorer.","category":"page"},{"location":"install_and_examples/","page":"Installation and Examples","title":"Installation and Examples","text":"explore(m)","category":"page"},{"location":"install_and_examples/","page":"Installation and Examples","title":"Installation and Examples","text":"This should open a window labeled \"Mimi Explorer Window\". On the left, there should be two vertically-stacked boxes. The top box is labeled \"Components\" and the bottom box is labeled \"Data\". To view some of the model output from our out-of-box BRICK simulation, you must first pick one of the Components from the top box, and then a Variable field out of the bottom box. For example, to view the global mean sea level model projections, select global_sea_level from the Components box, and global_sea_level : sea_level_rise from the Variables box. A plot of this variable should appear in the right column of plot boxes. The top box is static; the bottom box you can interact with to zoom in on different portions of the figure.","category":"page"},{"location":"install_and_examples/","page":"Installation and Examples","title":"Installation and Examples","text":"More information about exploring Mimi model results can be found in the Mimi Framework How-To guides online.","category":"page"},{"location":"install_and_examples/#DOECLIM-BRICK-(with-radiative-forcing)","page":"Installation and Examples","title":"DOECLIM-BRICK (with radiative forcing)","text":"","category":"section"},{"location":"install_and_examples/","page":"Installation and Examples","title":"Installation and Examples","text":"A simulation using DOECLIM to model temperature and ocean heat uptake, coupled to BRICK for sea-level rise can be constructed and run using the create_brick_doeclim() function. This function uses the MimiSNEASY package, which includes the DOECLIM model. Here we construct the model object m using the create_brick_doeclim() constructor, and run the model using the standard Mimi run(m).","category":"page"},{"location":"install_and_examples/","page":"Installation and Examples","title":"Installation and Examples","text":"m = MimiBRICK.create_brick_doeclim()\nrun(m)","category":"page"},{"location":"install_and_examples/","page":"Installation and Examples","title":"Installation and Examples","text":"These are using the default arguments in the model constructor for the DOECLIM-BRICK model:","category":"page"},{"location":"install_and_examples/","page":"Installation and Examples","title":"Installation and Examples","text":"rcp_scenario = \"RCP85\" - using Representative Concentration Pathway 8.5 as a default; other options include RCP26, RCP45, and RCP60\nstart_year = 1850 - starting year of the model simulation\nend_year = 2020 - ending year of the model simulation","category":"page"},{"location":"install_and_examples/","page":"Installation and Examples","title":"Installation and Examples","text":"So, if you wanted to instead run DOECLIM-BRICK using RCP 6.0 from 1800 to 2100, you could run:","category":"page"},{"location":"install_and_examples/","page":"Installation and Examples","title":"Installation and Examples","text":"m = MimiBRICK.create_brick_doeclim(rcp_scenario=\"RCP60\", start_year=1800, end_year=2100)\nrun(m)","category":"page"},{"location":"install_and_examples/","page":"Installation and Examples","title":"Installation and Examples","text":"And of course, you can use explore(m) to check out the model outputs attached to the model object m to verify that we have in fact changed RCP scenario and time periods. (Reminder: you'll need to have loaded the Mimi package using using Mimi to access the explore() function.)","category":"page"},{"location":"install_and_examples/#SNEASY-BRICK-(with-emissions-forcing)","page":"Installation and Examples","title":"SNEASY-BRICK (with emissions forcing)","text":"","category":"section"},{"location":"install_and_examples/","page":"Installation and Examples","title":"Installation and Examples","text":"Running a coupled model using SNEASY and BRICK proceeds in the same way as DOECLIM-BRICK. We can use the constructor for the coupled SNEASY-BRICK model, create, then run the coupled model.","category":"page"},{"location":"install_and_examples/","page":"Installation and Examples","title":"Installation and Examples","text":"m = MimiBRICK.create_sneasy_brick()\nrun(m)","category":"page"},{"location":"install_and_examples/","page":"Installation and Examples","title":"Installation and Examples","text":"The create_sneasy_brick() constructor has the same arguments as the DOECLIM-BRICK constructor, so you can change the RCP scenario and the time period.","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Running-baseline-cases-with-default-parameters-and-unit-tests","page":"Examples","title":"Running baseline cases with default parameters and unit tests","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"If you would like to take a look at the unit tests run with Continuous Integration for this package, feel free to take a look at the runtests.jl file, and the separate testing scripts it calls here.","category":"page"},{"location":"examples/#More-detailed-examples","page":"Examples","title":"More detailed examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Below, we review the three main configurations of the model that we anticipate being used. However, in the examples directory, you can find further examples conducting the statistical calibration, creating posterior model hindcasts and projections, and downscaling these hindcasts and projections to local sea-level changes. Those examples are in Jupyter notebooks. To open and run one, you will need to clone or fork the MimiBRICK.jl repository. Then, navigate to it in the Julia terminal and run:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Pkg; Pkg.add(IJulia)\nusing IJulia; notebook(dir=\"examples\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"You can then select and run the Jupyter notebook of your chosing in the Jupyter browser window (which will open in a web browser).","category":"page"},{"location":"examples/#BRICK-standalone-(with-temperature-and-ocean-heat-uptake-exogenous-forcing)","page":"Examples","title":"BRICK standalone (with temperature and ocean heat uptake exogenous forcing)","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This is the first test that is done in test/runtests/test_default.jl. Since it does not require DOECLIM or SNEASY, you can run BRICK using temperature and ocean heat uptake forcing data by running in the Julia console:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using MimiBRICK\nm = MimiBRICK.get_model()\nrun(m)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"You can plot the output fields in the model object m using (for example) the Plots Julia plotting package. First, let's grab the years over which the model was run. This is a dimension in the model. We can retrieve it by using the dim_keys() function, from the Mimi package.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Mimi\nyears = dim_keys(m, :time)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Then we can load the Plots package and make a figure of the global mean sea-level change. Note that the first argument into the m object specifies the component of our model, and the second argument specifies the field. Here, we are grabbing the sea_level_rise field from the global_sea_level component.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Plots\nplot(years, m[:global_sea_level, :sea_level_rise])","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Mimi also offers an explorer window to check these model output fields out. To use this, we need to load the Mimi package (if you haven't already).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Mimi","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Then, we can open the explorer.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"explore(m)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This should open a window labeled \"Mimi Explorer Window\". On the left, there should be two vertically-stacked boxes. The top box is labeled \"Components\" and the bottom box is labeled \"Data\". To view some of the model output from our out-of-box BRICK simulation, you must first pick one of the Components from the top box, and then a Variable field out of the bottom box. For example, to view the global mean sea level model projections, select global_sea_level from the Components box, and global_sea_level : sea_level_rise from the Variables box. A plot of this variable should appear in the right column of plot boxes. The top box is static; the bottom box you can interact with to zoom in on different portions of the figure.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"More information about exploring Mimi model results can be found in the Mimi Framework How-To guides online.","category":"page"},{"location":"examples/#DOECLIM-BRICK-(with-radiative-forcing)","page":"Examples","title":"DOECLIM-BRICK (with radiative forcing)","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"A simulation using DOECLIM to model temperature and ocean heat uptake, coupled to BRICK for sea-level rise can be constructed and run using the create_brick_doeclim() function. This function uses the MimiSNEASY package, which includes the DOECLIM model. Here we construct the model object m using the create_brick_doeclim() constructor, and run the model using the standard Mimi run(m).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"m = MimiBRICK.create_brick_doeclim()\nrun(m)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"These are using the default arguments in the model constructor for the DOECLIM-BRICK model:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"rcp_scenario = \"RCP85\" - using Representative Concentration Pathway 8.5 as a default; other options include RCP26, RCP45, and RCP60\nstart_year = 1850 - starting year of the model simulation\nend_year = 2020 - ending year of the model simulation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"So, if you wanted to instead run DOECLIM-BRICK using RCP 6.0 from 1800 to 2100, you could run:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"m = MimiBRICK.create_brick_doeclim(rcp_scenario=\"RCP60\", start_year=1800, end_year=2100)\nrun(m)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"And of course, you can use explore(m) to check out the model outputs attached to the model object m to verify that we have in fact changed RCP scenario and time periods. (Reminder: you'll need to have loaded the Mimi package using using Mimi to access the explore() function.)","category":"page"},{"location":"examples/#SNEASY-BRICK-(with-emissions-forcing)","page":"Examples","title":"SNEASY-BRICK (with emissions forcing)","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Running a coupled model using SNEASY and BRICK proceeds in the same way as DOECLIM-BRICK. We can use the constructor for the coupled SNEASY-BRICK model, create, then run the coupled model.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"m = MimiBRICK.create_sneasy_brick()\nrun(m)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The create_sneasy_brick() constructor has the same arguments as the DOECLIM-BRICK constructor, so you can change the RCP scenario and the time period.","category":"page"},{"location":"calibration/#Calibration","page":"Calibration","title":"Calibration","text":"","category":"section"},{"location":"calibration/","page":"Calibration","title":"Calibration","text":"placeholder","category":"page"},{"location":"#MimiBRICK.jl","page":"Home","title":"MimiBRICK.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MimiBRICK.jl is an implementation of the Building Blocks for Relevant Ice and Climate Knowledge (BRICK) semi-empirical model for sea-level change in the Mimi integrated modeling framework (https://www.mimiframework.org/). The Mimi modeling framework is a coding platform that facilitates coupling models and running coupled modeling experiments. MimiBRICK.jl is flexible, efficient, and modular, to facilitate incorporating BRICK into coupled models and integrated assessments of climate impacts in a modular fashion to provide global average as well as local sea-level projections. This focus on tight model coupling and integrated modeling is a key feature of MimiBRICK.jl and broader Mimi modeling framework.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This implementation includes examples for using observational data to calibrate the model, as well as various configurations in which MimiBRICK.jl is coupled to other climate model components. For users who do not wish to re-run computationally intensive model calibration algorithms, this implementation also includes scripts for using existing calibration output for standard future climate change scenarios, and examples downscaling these global projections for assessments of local impacts. Pre-run model calibration and simulation output can be found in the accompanying Zenodo repository.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [MimiBRICK]","category":"page"},{"location":"#MimiBRICK.calculate_trends-Tuple{Vector{Float64}, DataFrame, Int64, Int64}","page":"Home","title":"MimiBRICK.calculate_trends","text":"calculate_trends(model_output::Array{Float64,1}, obs_trends::DataFrame, start_year::Int, end_year::Int)\n\nCalculate modeled sea level trends.\n\nDescription: This function calculates the trend in different modeled sea level contributions over              a user-specified time period.\n\nFunction Arguments:\n\n  model_output = A vector of modeled annual sea level rise values.\n  obs_trends   = The matrix of observed sea level trends provided by the \"load_calibration_data\" function defined above.\n  start_year   = First year of the model run.\n  end_year     = Last year of the model run.\n\n\n\n\n\n","category":"method"},{"location":"#MimiBRICK.construct_brick_log_posterior-Tuple{Any}","page":"Home","title":"MimiBRICK.construct_brick_log_posterior","text":"construct_brick_log_posterior(f_run_model!; model_start_year::Int=1850, calibration_end_year::Int=2017, joint_antarctic_prior::Bool=false)\n\nCalculate log posterior for brick.\n\nDescription: This creates a function that calculates the log-posterior probability of the uncertain model, initial              condition, and statistical process parameters.\n\nFunction Arguments:\n\nf_run_model           = A function that runs the specific climate model version and returns the output being calibrated to observations.\nmodel_start_year      = First year to run the model (not necessarily first year of the calibration if model initializes earlier).\nend_year              = The final year to run the model calibration (defaults to 2017).\njoint_antarctic_prior = TRUE/FALSE check for whether to use a joint normal prior distribution (TRUE = option 1 described\n                        above) or fitted marginal kernel density estimates (FLASE = option 2 described above).\n\n\n\n\n\n","category":"method"},{"location":"#MimiBRICK.construct_brick_log_prior-Tuple{Bool}","page":"Home","title":"MimiBRICK.construct_brick_log_prior","text":"construct_brick_log_prior(joint_antarctic_prior::Bool; calibration_data_dir::Union{String, Nothing} = nothing)\n\nCalculate total (log) prior probability for brick.\n\nDescription: This creates a function that will calculate the total (log) prior probability of the uncertain model,              initial condition, and statistical process parameters specific to the standalone BRICK model. It uses              non-uniform priors for the Antarctic ice sheet parameters, informed by a previous model calibration to              paleo data. There are two options for the Antarctic priors (1) fitting marginal distributions using a              kernel density estimation or (2) fitting a multivariate normal distribution that accounts for correlations              that emerge during the paleo calibration (note, many of the marginal paleo pdfs are not normally distributed).\n\nFunction Arguments:\n\n  joint_antarctic_prior   = TRUE/FALSE check for whether to use a joint normal prior distribution (TRUE = option 1 described\n                          above) or fitted marginal kernel density estimates (FLASE = option 2 described above).\n  calibration_data_dir    = Data directory for calibration data. Defaults to package calibration data directory, \n                            changing this is not recommended.\n\n\n\n\n\n","category":"method"},{"location":"#MimiBRICK.construct_doeclimbrick_log_posterior-Tuple{Any}","page":"Home","title":"MimiBRICK.construct_doeclimbrick_log_posterior","text":"construct_doeclimbrick_log_posterior(f_run_model!; model_start_year::Int=1850, calibration_end_year::Int=2017, joint_antarctic_prior::Bool=false, uniform_ECS::Bool=false)\n\nCalculate log posterior for doeclimbrick.\n\nDescription: This creates a function that calculates the log-posterior probability of the uncertain model, initial              condition, and statistical process parameters.\n\nFunction Arguments:\n\nf_run_model           = A function that runs the specific climate model version and returns the output being calibrated to observations.\nmodel_start_year      = First year to run the model (not necessarily first year of the calibration if model initializes earlier).\nend_year              = The final year to run the model calibration (defaults to 2017).\njoint_antarctic_prior = TRUE/FALSE check for whether to use a joint normal prior distribution (TRUE = option 1 described\n                        above) or fitted marginal kernel density estimates (FLASE = option 2 described above).\nuniform_ECS           = TRUE/FALSE check for whether or not to use a uniform prior distribution for the equilibrium\n                        climate sensitivity (true = use uniform).\n\n\n\n\n\n","category":"method"},{"location":"#MimiBRICK.construct_doeclimbrick_log_prior-Tuple{Bool, Bool}","page":"Home","title":"MimiBRICK.construct_doeclimbrick_log_prior","text":"construct_doeclimbrick_log_prior(joint_antarctic_prior::Bool, uniform_ECS::Bool; calibration_data_dir::Union{String, Nothing} = nothing)\n\nCalculate total (log) prior probability for doeclimbrick.\n\nDescription: This creates a function that will calculate the total (log) prior probability of the uncertain model,              initial condition, and statistical process parameters specific to the DOECLIM-BRICK model. It uses              non-uniform priors for the Antarctic ice sheet parameters, informed by a previous model calibration to              paleo data. There are two options for the Antarctic priors (1) fitting marginal distributions using a              kernel density estimation or (2) fitting a multivariate normal distribution that accounts for correlations              that emerge during the paleo calibration (note, many of the marginal paleo pdfs are not normally distributed).\n\nFunction Arguments:\n\n  joint_antarctic_prior   = TRUE/FALSE check for whether to use a joint normal prior distribution (TRUE = option 1 described\n                          above) or fitted marginal kernel density estimates (FLASE = option 2 described above).\n  uniform_ECS             = TRUE/FALSE check for whether or not to use a uniform prior distribution for the equilibrium\n                          climate sensitivity (true = use uniform).\n  calibration_data_dir    = Data directory for calibration data. Defaults to package calibration data directory, changing this is not recommended.\n\n\n\n\n\n","category":"method"},{"location":"#MimiBRICK.construct_run_brick-Tuple{Int64, Int64}","page":"Home","title":"MimiBRICK.construct_run_brick","text":"construct_run_brick(calibration_start_year::Int, calibration_end_year::Int)\n\nCreate a function to run the BRICK model over the historic period.\n\n\n\n\n\n","category":"method"},{"location":"#MimiBRICK.construct_run_doeclimbrick-Tuple{Int64, Int64}","page":"Home","title":"MimiBRICK.construct_run_doeclimbrick","text":"construct_run_doeclimbrick(calibration_start_year::Int, calibration_end_year::Int)\n\nCreate a function to run the DOECLIM+BRICK model over the historic period.\n\n\n\n\n\n","category":"method"},{"location":"#MimiBRICK.construct_run_sneasybrick-Tuple{Int64, Int64}","page":"Home","title":"MimiBRICK.construct_run_sneasybrick","text":"construct_run_sneasybrick(calibration_start_year::Int, calibration_end_year::Int)\n\nCreate a function to run the SNEASY+BRICK model over the historic period.\n\n\n\n\n\n","category":"method"},{"location":"#MimiBRICK.construct_sneasybrick_log_posterior-Tuple{Any}","page":"Home","title":"MimiBRICK.construct_sneasybrick_log_posterior","text":"construct_sneasybrick_log_posterior(f_run_model!; model_start_year::Int=1850, calibration_end_year::Int=2017, joint_antarctic_prior::Bool=false, uniform_ECS::Bool=false)\n\nCalculate log posterior for sneasybrick.\n\nDescription: This creates a function that calculates the log-posterior probability of the uncertain model, initial              condition, and statistical process parameters.\n\nFunction Arguments:\n\nf_run_model           = A function that runs the specific climate model version and returns the output being calibrated to observations.\nmodel_start_year      = First year to run the model (not necessarily first year of the calibration if model initializes earlier).\nend_year              = The final year to run the model calibration (defaults to 2017).\njoint_antarctic_prior = TRUE/FALSE check for whether to use a joint normal prior distribution (TRUE = option 1 described\n                        above) or fitted marginal kernel density estimates (FLASE = option 2 described above).\nuniform_ECS           = TRUE/FALSE check for whether or not to use a uniform prior distribution for the equilibrium\n                        climate sensitivity (true = use uniform).\n\n\n\n\n\n","category":"method"},{"location":"#MimiBRICK.construct_sneasybrick_log_prior-Tuple{Bool, Bool}","page":"Home","title":"MimiBRICK.construct_sneasybrick_log_prior","text":"construct_sneasybrick_log_prior(joint_antarctic_prior::Bool, uniform_ECS::Bool; calibration_data_dir::Union{String, Nothing} = nothing)\n\nCalculate total (log) prior probability for sneasybrick.\n\nDescription: This creates a function that will calculate the total (log) prior probability of the uncertain model,              initial condition, and statistical process parameters specific to the SNEASY-BRICK model. It uses              non-uniform priors for the Antarctic ice sheet parameters, informed by a previous model calibration to              paleo data. There are two options for the Antarctic priors (1) fitting marginal distributions using a              kernel density estimation or (2) fitting a multivariate normal distribution that accounts for correlations              that emerge during the paleo calibration (note, many of the marginal paleo pdfs are not normally distributed).\n\nFunction Arguments:\n\n  joint_antarctic_prior   = TRUE/FALSE check for whether to use a joint normal prior distribution (TRUE = option 1 described\n                          above) or fitted marginal kernel density estimates (FLASE = option 2 described above).\n                          = TRUE/FALSE check for whether or not to use a uniform prior distribution for the equilibrium\n                          climate sensitivity (true = use uniform).\n  calibration_data_dir    = Data directory for calibration data. Defaults to package calibration data directory, changing this is not recommended.\n\n\n\n\n\n","category":"method"},{"location":"#MimiBRICK.create_brick_doeclim-Tuple{}","page":"Home","title":"MimiBRICK.create_brick_doeclim","text":"create_brick_doeclim(;rcp_scenario::String = \"RCP85\", start_year::Int=1850, end_year::Int=2020)\n\nReturn a Mimi model instance with MimiBRICK and DOECLIM coupled together.\n\nDescription: This function loads forcing data, sets up model parameters, and makes the model component variable connections.\n\nFunction Arguments:\n\n    rcp_scenario = RCP scenario for exogenous forcing\n    start_year   = initial year of the simulation period\n    end_year     = ending year of the simulation period\n\n\n\n\n\n","category":"method"},{"location":"#MimiBRICK.create_sneasy_brick-Tuple{}","page":"Home","title":"MimiBRICK.create_sneasy_brick","text":"create_sneasy_brick(;rcp_scenario::String = \"RCP85\", start_year::Int=1850, end_year::Int=2020)\n\nReturn a Mimi model instance with MimiBRICK and MimiSNEASY coupled together.\n\nDescription: This function loads forcing data, sets up model parameters, and makes the model component variable connections.\n\nFunction Arguments:\n\n    rcp_scenario = RCP scenario for exogenous forcing\n    start_year   = initial year of the simulation period\n    end_year     = ending year of the simulation period\n\n\n\n\n\n","category":"method"},{"location":"#MimiBRICK.downscale_brick-Tuple{}","page":"Home","title":"MimiBRICK.downscale_brick","text":"downscale_brick(;lon::Float64, \n                            lat::Float64, \n                            results_dir::String, \n                            proj_or_hind::String, \n                            ensemble_or_map::String, \n                            model_config::String, \n                            rcp_scenario::String=\"RCP85\"\n                        )\n\nDownscale BRICK projections to a single point, using either the whole ensemble or only the maximum a posteriori ensemble member. Note this function assumes a specific folder structure and file naming within the top level results_dir.\n\nFunction Arguments:\n\n- lon = longitude (degrees East) of location for downscaling\n- lat = latitude (degrees North) of location for downscaling\n- results_dir = the top level directory of results\n- proj_or_hind = \"proj\" for projections, or \"hind\" for hindcast\n- ensemble_or_map = \"ensemble\" for entire posterior ensemble, or \"map\" for the maximum a posteriori ensemble member (single simulation)\n- model_config = \"brick\", \"doeclimbrick\", or \"sneasybrick\"\n- rcp_scenario = \"RCP26\", \"RCP45\", \"RCP60\", or \"RCP85\" (default). Doesn't matter for hindcast.\n\n\n\n\n\n","category":"method"},{"location":"#MimiBRICK.get_fingerprints-Tuple{}","page":"Home","title":"MimiBRICK.get_fingerprints","text":"get_fingerprints()\n\nRetrieve BRICK fingerprints from NetCDF file - will download the file to a folder data directory\n\n\n\n\n\n","category":"method"},{"location":"#MimiBRICK.get_model-Tuple{}","page":"Home","title":"MimiBRICK.get_model","text":"get_model(;rcp_scenario::String=\"RCP85\", start_year::Int=1850, end_year::Int=2020)\n\nReturn a MimiBRICK model instance that can be modified and run.\n\nFunction Arguments:\n\n  rcp_scenario = RCP scenario for exogenous forcing\n  start_year   = initial year of the simulation period\n  end_year     = ending year of the simulation period\n\n\n\n\n\n","category":"method"},{"location":"#MimiBRICK.hetero_logl_ar1-Tuple{Vector{Float64}, Float64, Float64, Vector{Union{Missing, Float64}}}","page":"Home","title":"MimiBRICK.hetero_logl_ar1","text":"hetero_logl_ar1(residuals::Array{Float64,1}, σ::Float64, ρ::Float64, ϵ::Array{Union{Float64, Missings.Missing},1})\n\nCalculate AR(1) log-likelihood.\n\nDescription: This function calculates the AR(1) log-likelihood in terms of the data-model residuls when accounting for              time-varying observation errors. It follows \"The Effects of Time-Varying Observation Errors on Semi-Empirical              Sea-Level Projections\" (Ruckert et al., 2017) DOI 10.1007/s10584-016-1858-z.\n\nFunction Arguments:\n\n  residuals = A vector of data-model residuals.\n  σ         = AR(1) innovation standard deviation.\n  ρ         = AR(1) autocorrelation term.\n  ϵ         = A vector of time-varying observation error estimates (from calibration data sets).\n\n\n\n\n\n","category":"method"},{"location":"#MimiBRICK.hetero_logl_car1-Tuple{Vector{Float64}, Vector{Int64}, Float64, Float64, Vector{Union{Missing, Float64}}}","page":"Home","title":"MimiBRICK.hetero_logl_car1","text":"hetero_logl_car1(residuals::Array{Float64,1}, indices::Array{Int64,1}, σ²_white_noise::Float64, α₀::Float64, ϵ::Array{Union{Float64, Missings.Missing},1})\n\nCalculate CAR(1) log-likelihood.\n\nDescription: This function calculates the continuous time autoregressive, or CAR(1), log-likelihood for irregularly              spaced data in terms of the data-model residuls when accounting for time-varying observation errors. It              builds off of \"The Effects of Time-Varying Observation Errors on Semi-Empirical Sea-Level Projections\"              (Ruckert et al., 2017) DOI 10.1007/s10584-016-1858-z and \"The Analysis of Irregularly Observed Stochastic              Astronomical Time-Series – I. Basics of Linear Stochastic Differential Equations\" (Koen, 2005)              doi.org/10.1111/j.1365-2966.2005.09213.x\n\nFunction Arguments:\n\n  residuals      = A vector of data-model residuals.\n  indices        = Index positions of observations relative to model time horizon (i.e. the first model time period = 1, the second = 2, etc.).\n  σ²_white_noise = Variance of the continuous white noise process.\n  α₀             = Parameter describing correlation memory of CAR(1) process.\n  ϵ              = A vector of time-varying observation error estimates (from calibration data sets).\n\n\n\n\n\n","category":"method"},{"location":"#MimiBRICK.load_calibration_data-Tuple{Int64, Int64}","page":"Home","title":"MimiBRICK.load_calibration_data","text":"load_calibration_data(model_start_year::Int, last_calibration_year::Int; last_sea_level_norm_year::Int=1990, calibration_data_dir::Union{Nothing, String} = nothing)\n\nLoad and clean up data used for model calibration.\n\nDescription: This function loads, cleans up, and merges all of the calibration data into a single dataframe.\n\nFunction Arguments:\n\n- model_start_year         = The first year to include in the calibration data set.\n- last_calibration_year    = The last year to run the model for calibration (i.e. 1980 will not consider any post-1980 observations).\n- last_sea_level_norm_year = Some sea level data sets may need to be normalized to different years depending on when the calibration ends (this\n                             may be necessary for out-of-sample tests). These data sets will be normalized from 1961-last norm year, default = 1961-1990.\n- calibration_data_dir    = Data directory for calibration data. Defaults to package calibration data directory, changing this is not recommended.\n\n\n\n\n\n","category":"method"},{"location":"#MimiBRICK.next_lat-Tuple{Float64, Int64, Symbol}","page":"Home","title":"MimiBRICK.next_lat","text":"next_lat(lat::Float64, inc::Int, direction::Symbol)\n\nIncrement latitude by inc in either positive direction (direction=:increase) or in the negative direction (direction=:decrease). Assumes latitude runs from -90 to 90 (deg N).\n\n\n\n\n\n","category":"method"},{"location":"#MimiBRICK.next_lon-Tuple{Float64, Int64, Symbol}","page":"Home","title":"MimiBRICK.next_lon","text":"next_lon(lon::Float64, inc::Int, direction::Symbol)\n\nIncrement longitude by inc in either positive direction (direction=:increase) or in the negative direction (direction=:decrease). Assumes longitude runs from 0 to 360 (deg E).\n\n\n\n\n\n","category":"method"},{"location":"#MimiBRICK.replicate_errors-Tuple{Int64, Int64, Any}","page":"Home","title":"MimiBRICK.replicate_errors","text":"replicate_errors(start_year::Int, end_year::Int, error_data)\n\nREPLICATE TIME-VARYING OBSERVATION ERRORS FOR PERIODS WITHOUT COVERAGE.\n\nDescription: This function creates a time-series of observation errors for the entire model time horizon. For years              without observation error estimates, the error remains constant at the average of the ten nearest error              values in time.\n\nFunction Arguments:\n\n  start_year = The first year to run the climate model.\n  end_year   = The final year to run the climate model.\n  error_data = A vector of time-varying observation errors supplied with each calibration data set.\n\n\n\n\n\n","category":"method"},{"location":"#MimiBRICK.run_calibration-Tuple{}","page":"Home","title":"MimiBRICK.run_calibration","text":"run_calibration(;   output_dir::String, \n                    model_config=\"brick\", \n                    calibration_start_year=1850, \n                    calibration_end_year=2005,\n                    total_chain_length=1000, \n                    burnin_length=0, \n                    threshold_gr=1.1, \n                    num_walkers=2,\n                    size_subsample=1000, \n                    start_from_priors=false,\n                    calibration_data_dir::Union{String, Nothing} = nothing\n                )\n\nThis function carries out a Markov chain Monte Carlo calibration of BRICK. This includes one of the following possible model configurations set with model_config     (1) BRICK standalone (forced by input global mean surface temperatures and ocean heat uptake data)     (2) DOECLIM+BRICK     (3) SNEASY+BRICK\n\n\n\n\n\n","category":"method"},{"location":"#MimiBRICK.run_hindcast-Tuple{}","page":"Home","title":"MimiBRICK.run_hindcast","text":"run_hindcast(; output_dir::String,\n                model_config::String = \"brick\",\n                start_year::Int = 1850,\n                end_year = 2017,\n            )\n\nFunction to run BRICK (standalone, or with DOECLIM or SNEASY) over the historic period and save the hindcast results to CSV files. \n\nFunction Arguments:\n\n- outdir - paths for results files - subsample of model parameters, and associated log-posterior scores, and printed results of this function\n- model_config (default = \"brick\") - model configuration with possible options: (1) \"brick\", (2) \"doeclimbrick\", (3) \"sneasybrick\"\n- start_year (default = 1850) - start year for calibration\n- end_year (default = 2017) - end year for calibration\n\n\n\n\n\n","category":"method"},{"location":"#MimiBRICK.run_projections-Tuple{}","page":"Home","title":"MimiBRICK.run_projections","text":"run_projections(; output_dir::String,\n                    model_config::String = \"brick\",\n                    rcp_scenario::String = \"RCP85\",\n                    start_year::Int = 1850,\n                    end_year = 2300,\n                )\n\nFunction to run BRICK (standalone, or with DOECLIM or SNEASY) over the projections period and save the results to CSV files. \n\nFunction Arguments:\n\n- outdir - paths for results files - subsample of model parameters, and associated log-posterior scores, and printed results of this function\n- model_config (default = \"brick\") - model configuration with possible options: (1) \"brick\", (2) \"doeclimbrick\", (3) \"sneasybrick\"\n- rcp_scenario (default = \"RCP85) - RCP scenario with possible options: (1) RCP26, (2) RCP45, (3) RCP60, (4) RCP85\n- start_year (default = 1850) - start year for calibration\n- end_year (default = 2300) - end year for calibration\n\n\n\n\n\n","category":"method"},{"location":"#MimiBRICK.simulate_ar1_noise-Tuple{Int64, Float64, Float64, Vector{Float64}}","page":"Home","title":"MimiBRICK.simulate_ar1_noise","text":"simulate_ar1_noise(n::Int, σ::Float64, ρ::Float64, ϵ::Array{Float64,1})\n\nSimulate stationary AR(1) process with time varying observation errors.\n\nDescription: This function simulates a stationary AR(1) process (given time-varying observation errors supplied with              each calibration data set) to superimpose noise onto the climate model projections.\n\nFunction Arguments:\n\n  n = Number of time periods (years) the model is being run for.\n  σ = Calibrated standard deviation.\n  ρ = Calibrated autocorrelation coefficient.\n  ϵ = Time-varying observation errors.\n\n\n\n\n\n","category":"method"},{"location":"#MimiBRICK.simulate_car1_noise-NTuple{4, Any}","page":"Home","title":"MimiBRICK.simulate_car1_noise","text":"simulate_car1_noise(n, α₀, σ²_white_noise, ϵ)\n\nSimulate stationary CAR(1) process with time varying observation errors.\n\nDescription: This function simulates a stationary CAR(1) process (given time-varying observation errors supplied with              each calibration data set) to superimpose noise onto the climate model projections.\n\nFunction Arguments:\n\n  n              = Number of time periods (years) the model is being run for.\n  α₀             = Calibrated term describing correlation memory of CAR(1) process.\n  σ²_white_noise = Calibrated continuous white noise process variance term.\n  ϵ              = Time-varying observation errors.\n\n\n\n\n\n","category":"method"},{"location":"#MimiBRICK.truncated_kernel-Tuple{Any, Any, Any}","page":"Home","title":"MimiBRICK.truncated_kernel","text":"truncated_kernel(data, lower_bound, upper_bound)\n\nCalculate kernel density estimates with truncated bounds.\n\nDescription: This function creates a fitted kernel density object (from KernelDensity.jl package) and              crops the edges to user-specified lower and upper bounds (setting boundaries beforehand,              can lead to issues with some parameters because, \"Due to the fourier transforms used              internally, there should be sufficient spacing to prevent wrap-around at the boundaries\")\n\nFunction Arguments:\n\n  data        = Parameter samples used for the kernel density estimate.\n  lower_bound = Minimum parameter value corresponding to the lower bound of the fitted density.\n  upper_bound = Maximum parameter value corresponding to the upper bound of the fitted density.\n\n\n\n\n\n","category":"method"},{"location":"#Author-Contributions","page":"Home","title":"Author Contributions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TW: initial model development, software development, model calibration and validation, conceptualization, projection direction and overall management\nLR: software development, package maintenance, conceptualization\nFE: software development, model calibration and validation, conceptualization\nVS: software testing, model calibration and validation, conceptualization\nAB: initial model development, software testing, conceptualization\nKK: software testing, conceptualization\nDA: software development, package maintenance, conceptualization, project direction","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Copyright 2022 Tony Wong, Lisa Rennels, Frank Errickson, Vivek Srikrishnan, Alexander Bakker, Klaus Keller, and David Anthoff","category":"page"},{"location":"","page":"Home","title":"Home","text":"This file and codes in this repository are part of MimiBRICK.jl (Building blocks for Relevant Ice and Climate Knowledge). MimiBRICK.jl is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.","category":"page"},{"location":"","page":"Home","title":"Home","text":"MimiBRICK.jl is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.","category":"page"},{"location":"","page":"Home","title":"Home","text":"You should have received a copy of the GNU General Public License along with MimiBRICK.jl (LICENSE.md)). If not, see http://www.gnu.org/licenses/.","category":"page"}]
}
